# BombTask (FastAPI)

## Описание

Реализация тестового задания для управления сущностями **Счет (Account)** и **Транзакция (Transaction)**.  
Задание требовало Django+DRF, но реализовано на FastAPI (по согласованию).

## Основные сущности

### Account (Счет)
- `id`: UUID (строка)
- `owner_name`: имя владельца (строка)
- `balance`: баланс (Decimal)
- `created_at`: дата/время создания
- `updated_at`: дата/время обновления

### Transaction (Транзакция)
- `id`: UUID (строка)
- `from_account`: ссылка на Account (отправитель)
- `to_account`: ссылка на Account (получатель)
- `amount`: сумма (Decimal)
- `created_at`: дата/время создания
- `updated_at`: дата/время обновления

## Функционал API

- **Создание счета**: POST `/api/v1/account/`
- **Получение списка всех счетов**: GET `/api/v1/account/all`
- **Получение информации по конкретному счету**: GET `/api/v1/account/{uid}`
- **Создание транзакции между счетами**: POST `/api/v1/transaction/`
  - Проверка достаточности средств у исходного счета
  - Запрет перевода самому себе
  - Запрет перевода отрицательной суммы (валидация на уровне схемы)
- **Ограничение частоты запросов** (rate limiting) для всех эндпоинтов
- **Кэширование** информации о счете (GET `/api/v1/account/{uid}`) с инвалидацией по изменению

## Архитектура и паттерны

- **Service/Repository**:  
  Вся бизнес-логика вынесена в абстрактный класс `Base` (`settings/database.py`), который реализует паттерн Repository/Service для всех моделей.  
  Методы: `get`, `get_all`, `create`, `update`, `delete` и др.  
  Это обеспечивает чистое разделение бизнес-логики и работы с данными.

- **Асинхронность**:  
  Весь стек построен на асинхронных библиотеках (FastAPI, SQLAlchemy async, asyncpg, aiohttp).

- **Rate Limiting**:  
  Используется пакет `slowapi` для ограничения количества запросов (например, 20 запросов в минуту на создание/чтение счетов, 10 — на транзакции).

- **Кэширование**:  
  Используется Redis и fastapi-cache2 для кэширования ответов на получение счета.

- **Валидация и сериализация**:  
  Pydantic-схемы для строгой валидации входных и выходных данных.

- **Документация**:  
  Swagger UI доступен по `/docs`.

## Дополнительная фича

**Кэширование информации о счете с инвалидацией по изменению**  
- При запросе информации о счете (`GET /api/v1/account/{uid}`) используется кэш Redis.
- Ключ кэша строится с учетом времени последнего обновления счета (`updated_at`), что гарантирует автоматическую инвалидацию кэша при изменении баланса или других данных.
- Это позволяет значительно снизить нагрузку на БД при частых запросах к одним и тем же счетам, что особенно актуально для финансовых сервисов.

## Запуск проекта

### Через Docker Compose

```bash
docker-compose up --build
```

### Локально

1. Установить зависимости:
   ```bash
   poetry install
   ```
2. Заполнить `.env` (см. переменные в `settings/config.py`)
3. Применить миграции:
   ```bash
   poetry run alembic upgrade head
   ```
4. Запустить приложение:
   ```bash
   poetry run python main.py
   ```

## Примеры запросов

### Создать счет

```http
POST /api/v1/account/
{
  "owner_name": "Иван Иванов",
  "balance": 1000.00
}
```

### Получить все счета

```http
GET /api/v1/account/all
```

### Получить счет по id

```http
GET /api/v1/account/{uuid}
```

### Создать транзакцию

```http
POST /api/v1/transaction/
{
  "from_account": "{uuid1}",
  "to_account": "{uuid2}",
  "amount": 100.00
}
```

## Критерии бизнес-логики

- Нельзя перевести деньги самому себе
- Нельзя перевести сумму больше, чем есть на счете отправителя
- Нельзя перевести отрицательную сумму (валидация схемы)
- Все операции атомарны и асинхронны

